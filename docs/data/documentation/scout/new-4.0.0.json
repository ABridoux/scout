{"metadata":{"roleHeading":"Article","role":"article","title":"What’s new in Scout  4.0.0","modules":[{"name":"Scout"}]},"kind":"article","sections":[],"abstract":[{"type":"text","text":"Learn the new features of Scout 4.0.0 as well as what was broken or deprecated"}],"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/Scout\/documentation\/Scout\/new-4.0.0"},"hierarchy":{"paths":[["doc:\/\/Scout\/documentation\/Scout"]]},"schemaVersion":{"patch":0,"minor":3,"major":0},"primaryContentSections":[{"kind":"content","content":[{"text":"General","anchor":"General","type":"heading","level":2},{"type":"paragraph","inlineContent":[{"text":"Scout 4.0.0 is a global refactor of the code base. This was a necessary step to offer new features. Also, the code is now more robust, faster and more flexible to welcome new features.","type":"text"}]},{"type":"heading","level":3,"text":"New data structure","anchor":"New-data-structure"},{"type":"paragraph","inlineContent":[{"type":"text","text":"To reach this goal, a new data structure has been chosen to represent a "},{"isActive":true,"identifier":"doc:\/\/Scout\/documentation\/Scout\/PathExplorer","type":"reference"},{"type":"text","text":" values. The "},{"type":"codeVoice","code":"ExplorerValue"},{"text":" in an indirect enum and thus is a purely functional structure. For Scout features, it allows to write less and cleaner code, but also to remove the need to manage the states a PathExplorer had in the previous versions.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This new data structure also allows to use Codable to encode and decode data, which offers several new possibilities, like customizing a "},{"type":"codeVoice","code":"Coder"},{"type":"text","text":" to better fit one’s use case, or to set and add Codable types with no effort (more on that)."}]},{"name":"Note","type":"aside","style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"The XML parsing has not changed and still uses AEXML. I tried in several ways to use ExplorerValue with a XML coder but this always led to informations loss or strange behaviors. Thus I rather rewrote the XML features with this new ”functional mindset” and I believe it is clearer. Also, small new features like attributes reading are now offered."}]}]},{"level":3,"anchor":"New-path-parsing","type":"heading","text":"New path parsing"},{"type":"paragraph","inlineContent":[{"text":"The Path parsing is now done with a Parser rather than with regular expressions. This is more robust and faster. The same goes for parsing a path and its value when adding or setting a value with the command-line tool.","type":"text"}]},{"text":"Breaking changes","anchor":"Breaking-changes","type":"heading","level":3},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Adding a value to a path with non-existing keys and indexes will not work anymore. Only when an element of the path is the last will it be valid to add a new key. The solution is now to create empty dictionaries or arrays and fill them after.","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Setting or adding values will no more work with "},{"type":"codeVoice","code":"Any"},{"type":"text","text":" values but with "},{"type":"reference","identifier":"doc:\/\/Scout\/documentation\/Scout\/ExplorerValueRepresentable","isActive":true}]}]}],"type":"unorderedList"},{"type":"heading","level":3,"anchor":"New-features","text":"New features"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Usage of "},{"type":"codeVoice","code":"Codable"},{"text":" for Plist, JSON and YAML rather than serialization types to encode and decode data. This means that any Encoder or Decoder can be used with it.","type":"text"}]}]},{"content":[{"inlineContent":[{"code":"Data","type":"codeVoice"},{"text":" and ","type":"text"},{"type":"codeVoice","code":"Date"},{"text":" values are now supported.","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"It’s now possible to set or add a dictionary or an array value to an explorer. Also, in Swift, a type conforming to "},{"isActive":true,"identifier":"doc:\/\/Scout\/documentation\/Scout\/ExplorerValueRepresentable","type":"reference"},{"text":" can be set or added. A default implementation is provided for Codable types.","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"XML attributes can now be read. In Swift, new options offer to keep the attributes, and to specify a strategy to handle single child elements when exporting a XML explorer.","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Import a CSV file to one of the available formats with a precisely shaped structure."}]}]}],"type":"unorderedList"},{"anchor":"ExplorerValue","level":2,"type":"heading","text":"ExplorerValue"},{"inlineContent":[{"type":"text","text":"Serializable PathExplorers like Plist, JSON and YAML or others like XML can use this type to set, add, or read a value."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The new "},{"type":"codeVoice","code":"ExplorerValue"},{"type":"text","text":" is the following enum."}]},{"code":["public enum ExplorerValue {","    case int(Int)","    case double(Double)","    case string(String)","    case bool(Bool)","    case data(Data)","    case date(Date)","    case array([ExplorerValue])","    case dictionary([String: ExplorerValue])","}"],"syntax":"swift","type":"codeListing"},{"level":3,"text":"Expressible","anchor":"Expressible","type":"heading"},{"inlineContent":[{"type":"codeVoice","code":"ExplorerValue"},{"type":"text","text":" implements the “Expressible” protocols when it’s possible for the types it deals with. This means that it’s possible to define an ExplorerValue like the following examples."}],"type":"paragraph"},{"syntax":"swift","code":["let string: ExplorerValue = \"string\"","let dict: ExplorerValue = [\"foo\": \"bar\"]","let array: ExplorerValue = [\"Riri\", \"Fifi\", \"Loulou\"]"],"type":"codeListing"},{"level":3,"type":"heading","text":"Codable","anchor":"Codable"},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"ExplorerValue"},{"text":" conforms to ","type":"text"},{"code":"Codable","type":"codeVoice"},{"text":". The new SerializablePathExplorer (used for JSON, Plist and XML) uses this conformance to offer initialization from Data. But this also means that any Coder can be used to read an ","type":"text"},{"type":"codeVoice","code":"ExplorerValue"},{"type":"text","text":" from Data. This was already possible to use a different serializer than the default one in the previous implementations. But customizing a Coder is much simpler and now more common in Swift. For instance, setting a custom "},{"code":"Date","type":"codeVoice"},{"text":" decoding strategy is always offered in most coders.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"be"}]},{"type":"heading","anchor":"Conversion-with-ExplorerValueRepresentable","level":3,"text":"Conversion with ExplorerValueRepresentable"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Setting and adding a value to an explorer now works with ExplorerValue. For instance, to set Tom’s age to 60:"}]},{"code":["json.set(\"Tom\", \"age\", to: .int(60))"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"type":"text","text":"Of course, convenience types and functions are offered, so the line above can be written like this:"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["json.set(\"Tom\", \"age\", to: 60)"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This is made possible with the "},{"code":"ExplorerValueRepresentable","type":"codeVoice"},{"type":"text","text":" protocol. It only requires a function to convert the type to an ExplorerValue."}]},{"type":"codeListing","code":["protocol ExplorerValueRepresentable {","    func explorerValue() throws -> ExplorerValue","}"],"syntax":"swift"},{"inlineContent":[{"type":"text","text":"Default implementations are provided for the values mapped by ExplorerValue like "},{"code":"String","type":"codeVoice"},{"type":"text","text":", "},{"code":"Double","type":"codeVoice"},{"text":", an ","type":"text"},{"type":"codeVoice","code":"Array"},{"text":" if its ","type":"text"},{"type":"codeVoice","code":"Element"},{"type":"text","text":" conforms to "},{"isActive":true,"type":"reference","identifier":"doc:\/\/Scout\/documentation\/Scout\/ExplorerValueRepresentable"},{"type":"text","text":" and a "},{"code":"Dictionary","type":"codeVoice"},{"text":" if its ","type":"text"},{"type":"codeVoice","code":"Value"},{"text":" conforms to ExplorerValueRepresentable.","type":"text"},{"text":" ","type":"text"},{"text":"Some examples:","type":"text"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["let stringValue = \"toto\"","try json.set(\"name\", to: stringValue)","let dict = [\"firstName\": \"Riri\", \"lastName\": \"Duck\"]","try json.set(\"profile\", to: dict)"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Also, a default implementation for any "},{"code":"Encodable","type":"codeVoice"},{"text":" type is provided. An Encoder is implemented to encode a type to an ","type":"text"},{"type":"codeVoice","code":"ExplorerValue"},{"text":". Similarly, a ","type":"text"},{"type":"codeVoice","code":"Decoder"},{"type":"text","text":" is implemented to decode an ExplorerValue to a Decodable type with the protocol ExplorerValueCreatable. A type alias is provided to group both protocols:"}]},{"code":["ExplorerValueConvertible = ExplorerValueRepresentable & ExplorerValueCreatable"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"For instance with a simple struct.","type":"text"}]},{"syntax":"swift","code":["struct Record: Codable, ExplorerValueConvertible {","    var name: String","    var score: Int","}","","let record = Record(name: \"Riri\", score: 20)"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"It’s then possible to set the record value at a specific path.","type":"text"}]},{"syntax":"swift","code":["plist.set(\"ducks\", \"records\", 0, to: record)"],"type":"codeListing"},{"anchor":"About-XML","level":3,"text":"About XML","type":"heading"},{"type":"paragraph","inlineContent":[{"text":"The new ","type":"text"},{"identifier":"doc:\/\/Scout\/documentation\/Scout\/ExplorerXML","isActive":true,"type":"reference"},{"text":" can also set and add ","type":"text"},{"type":"codeVoice","code":"ExplorerValues"},{"type":"text","text":", as well as be converted to one. Because XML is not serializable, this process might loose informations. Options to keep attributes and single child strategies are offered. This is useful in the conversion features like XML → JSON. Whenever it’s possible, "},{"type":"codeVoice","code":"ExplorerXML"},{"type":"text","text":" will keep as much information as possible. When it’s not possible, the type will act consistently. For instance, when setting a new "},{"code":"Array","type":"codeVoice"},{"type":"text","text":" value, the children of the XML element will all be named “Element”."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In Swift, it’s possible to rather set an AEXMLElement to have more freedom on the children. This requires more work, but I believe it’s a good thing to have this possibility. To know how to create and edit AEXMLElements, you can checkout the "},{"isActive":true,"type":"reference","identifier":"https:\/\/github.com\/tadija\/AEXML"},{"text":".","type":"text"}]},{"level":2,"text":"CSV import","anchor":"CSV-import","type":"heading"},{"inlineContent":[{"type":"text","text":"A new CSV import feature is available to convert a CSV input as JSON, Plist, YAML or XML. A cool feature when working with named headers is that they will be treated as paths. This can shape very precisely the structure of the converted data. For instance, the following CSV"}],"type":"paragraph"},{"syntax":"csv","type":"codeListing","code":["name.first;name.last;hobbies[0];hobbies[1]","Robert;Roni;acting;driving","Suzanne;Calvin;singing;play","Tom;Cattle;surfing;watching movies"]},{"type":"paragraph","inlineContent":[{"text":"will be converted to the following Json structure.","type":"text"}]},{"syntax":"json","code":["[","  {","    \"hobbies\" : [","      \"acting\",","      \"driving\"","    ],","    \"name\" : {","      \"first\" : \"Robert\",","      \"last\" : \"Roni\"","    }","  },","  {","    \"hobbies\" : [","      \"singing\",","      \"play\"","    ],","    \"name\" : {","      \"first\" : \"Suzanne\",","      \"last\" : \"Calvin\"","    }","  },","  {","    \"name\" : {","      \"first\" : \"Tom\",","      \"last\" : \"Cattle\"","    },","    \"hobbies\" : [","      \"surfing\",","      \"watching movies\"","    ]","  }","]"],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"When there are no headers, the input will be treated as a one or two dimension(s) array."},{"type":"text","text":" "},{"text":"To create a ","type":"text"},{"type":"codeVoice","code":"PathExplorer"},{"text":" from a CSV string, use ","type":"text"},{"identifier":"doc:\/\/Scout\/documentation\/Scout\/SerializablePathExplorer\/fromCSV(string:separator:hasHeaders:)","type":"reference","isActive":true},{"type":"text","text":" function."}],"type":"paragraph"},{"code":["let json = PathExplorers.Json.fromCSV(csvString, separator: \";\", hasHeaders: true)"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"type":"text","text":"The "},{"code":"hasHeaders","type":"codeVoice"},{"text":" boolean is needed to specify whether the CSV string begins with named headers.","type":"text"}],"type":"paragraph"}]}],"variants":[{"paths":["\/documentation\/scout\/new-4.0.0"],"traits":[{"interfaceLanguage":"swift"}]}],"references":{"doc://Scout/documentation/Scout":{"abstract":[{"type":"text","text":"This library aims to make specific formats data values reading and writing simple when the data format is not known at build time."}],"identifier":"doc:\/\/Scout\/documentation\/Scout","url":"\/documentation\/scout","type":"topic","role":"collection","title":"Scout","kind":"symbol"},"doc://Scout/documentation/Scout/ExplorerValueRepresentable":{"type":"topic","url":"\/documentation\/scout\/explorervaluerepresentable","role":"symbol","title":"ExplorerValueRepresentable","identifier":"doc:\/\/Scout\/documentation\/Scout\/ExplorerValueRepresentable","fragments":[{"text":"protocol","kind":"keyword"},{"text":" ","kind":"text"},{"text":"ExplorerValueRepresentable","kind":"identifier"}],"navigatorTitle":[{"kind":"identifier","text":"ExplorerValueRepresentable"}],"abstract":[{"type":"text","text":"Can be represented as an "},{"code":"ExplorerValue","type":"codeVoice"}],"kind":"symbol"},"doc://Scout/documentation/Scout/SerializablePathExplorer/fromCSV(string:separator:hasHeaders:)":{"fragments":[{"text":"static","kind":"keyword"},{"text":" ","kind":"text"},{"text":"func","kind":"keyword"},{"kind":"text","text":" "},{"kind":"identifier","text":"fromCSV"},{"kind":"text","text":"("},{"text":"string","kind":"externalParam"},{"text":": ","kind":"text"},{"preciseIdentifier":"s:SS","text":"String","kind":"typeIdentifier"},{"kind":"text","text":", "},{"kind":"externalParam","text":"separator"},{"text":": ","kind":"text"},{"preciseIdentifier":"s:SJ","text":"Character","kind":"typeIdentifier"},{"kind":"text","text":", "},{"kind":"externalParam","text":"hasHeaders"},{"text":": ","kind":"text"},{"preciseIdentifier":"s:Sb","text":"Bool","kind":"typeIdentifier"},{"text":") ","kind":"text"},{"text":"throws","kind":"keyword"},{"text":" -> ","kind":"text"},{"kind":"typeIdentifier","text":"Self"}],"identifier":"doc:\/\/Scout\/documentation\/Scout\/SerializablePathExplorer\/fromCSV(string:separator:hasHeaders:)","kind":"symbol","title":"fromCSV(string:separator:hasHeaders:)","abstract":[{"type":"text","text":"Returns a new explorer from the provided CSV string when it’s possible."}],"required":true,"url":"\/documentation\/scout\/serializablepathexplorer\/fromcsv(string:separator:hasheaders:)","role":"symbol","type":"topic"},"https://github.com/tadija/AEXML":{"identifier":"https:\/\/github.com\/tadija\/AEXML","title":"repo","url":"https:\/\/github.com\/tadija\/AEXML","titleInlineContent":[{"type":"text","text":"repo"}],"type":"link"},"doc://Scout/documentation/Scout/ExplorerXML":{"title":"ExplorerXML","url":"\/documentation\/scout\/explorerxml","abstract":[],"type":"topic","kind":"symbol","fragments":[{"kind":"keyword","text":"struct"},{"text":" ","kind":"text"},{"kind":"identifier","text":"ExplorerXML"}],"navigatorTitle":[{"text":"ExplorerXML","kind":"identifier"}],"role":"symbol","identifier":"doc:\/\/Scout\/documentation\/Scout\/ExplorerXML"},"doc://Scout/documentation/Scout/PathExplorer":{"title":"PathExplorer","kind":"symbol","abstract":[{"type":"text","text":"Wrap several structs to explore several format: Json, Plist, YAML and Xml"}],"type":"topic","url":"\/documentation\/scout\/pathexplorer","role":"symbol","navigatorTitle":[{"kind":"identifier","text":"PathExplorer"}],"identifier":"doc:\/\/Scout\/documentation\/Scout\/PathExplorer","fragments":[{"text":"protocol","kind":"keyword"},{"text":" ","kind":"text"},{"text":"PathExplorer","kind":"identifier"}]}}}